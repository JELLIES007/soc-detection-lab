# SOC Detection Lab

A structured, test-driven SOC detection lab focused on parsing and normalizing **Snort fast alert logs** into SIEM-ready data structures.  
This project emphasizes correctness, resilience to real-world alert variations, and professional SOC engineering practices.

---

## üìå Project Overview

The **SOC Detection Lab** is designed to simulate a real-world detection pipeline component by ingesting Snort fast alerts, parsing them reliably, and converting them into structured, normalized alert objects suitable for SIEM ingestion (ELK, Splunk, SOAR tools).

Key goals:
- Robust parsing of Snort fast alert format
- Support for IPv4 and IPv6 traffic
- Graceful handling of protocol differences (TCP, UDP, ICMP)
- Test-driven development with pytest
- Clean, scalable Python project structure

---

## üìÅ Project Structure


### Folder Breakdown
- **`src/`** ‚Äì Application source code
- **`src/parsers/snort_fast.py`** ‚Äì Snort fast alert parser implementation
- **`tests/`** ‚Äì Automated test suite
- **`venv/`** ‚Äì Python virtual environment
- **`pytest.ini`** ‚Äì Pytest configuration
- **`.pytest_cache/` / `__pycache__/`** ‚Äì Runtime caches
- **`README.md`** ‚Äì Project documentation

---

## üêç Environment Setup

A Python virtual environment was created to ensure:
- Dependency isolation
- Reproducible testing
- Clean separation from system Python

All development and testing is performed inside the virtual environment.

---

## üö® Snort Fast Alert Parser

### Parser Location

### Implemented Features
The parser supports:
- Snort fast alert format
- IPv4 and IPv6 addresses
- TCP, UDP, and ICMP protocols
- Optional ports (ICMP / no-port alerts)
- Priority-to-severity normalization
- Immutable alert objects using dataclasses
- JSON and dictionary serialization for SIEM ingestion

### Core Functions
- `parse_fast_line()` ‚Äì Parse a single alert line
- `parse_fast_file()` ‚Äì Stream-parse alert files safely
- `priority_to_severity()` ‚Äì Normalize Snort priority values

### Alert Object
Alerts are represented using a frozen dataclass:

- Timestamp
- GID / SID / Revision
- Message
- Priority and SOC-style severity
- Protocol
- Source and destination IPs
- Optional ports
- Tool identifier (`snort`)

---

## üîç Regex Hardening & Edge Case Handling

The parser regex was hardened to support real SOC conditions:
- IPv4 and IPv6 compatibility
- Optional port fields
- ICMP alerts without ports
- Correct handling of literal braces in f-strings
- Backward compatibility with IPv4-only alerts

This ensures the parser does not fail on common real-world alert variations.

---

## üß™ Testing (pytest)

### Test Coverage
The test suite validates:
- Priority-to-severity mapping
- TCP alert parsing
- UDP alert parsing
- ICMP alert parsing (no ports)
- IPv6 alert parsing
- Blank and malformed line handling

### Test File

### Pytest Configuration
A `pytest.ini` file ensures:
- Project root is on `PYTHONPATH`
- `src/` imports resolve correctly
- Tests are discovered under `tests/`

---

## ‚úÖ Test Results

Final test run:

```bash
pytest -q
5 passed in 0.02s

## Week 1 ‚Äî Live Snort Validation (Snapshot)

**Tag:** Week_1_Live_Snort_Validation

### Objective
Validate the detection pipeline against alerts generated by a real Snort IDS sensor instead of sample data.

### Work Completed
- Installed and configured Snort 2.9 on Linux Mint (Ubuntu noble base)
- Validated Snort configuration and rule loading
- Created and enabled a local ICMP test rule
- Generated real alerts using live traffic (Wi-Fi and loopback)
- Identified actual alert output location (`/var/log/snort/alert`)
- Implemented a unified Snort parser that supports real alert formats
- Normalized parsed alerts into a consistent event schema
- Added pytest coverage for real alert parsing
- Verified full test suite passes with live data included

### Outcome
The application now successfully parses real IDS alerts produced by a live Snort sensor and validates behavior through automated tests.

This confirms the system operates beyond a lab-only or mock-data context and behaves as a real SOC detection component.


## Results

The detection pipeline successfully parsed and analyzed Snort alert logs, producing a SOC-style summary report.

- Parsed 5 alert events from a real Snort alert file
- Identified repeated activity from a single source IP (127.0.0.1), accounting for 80% of alerts
- Classified alerts by severity based on Snort Priority fields
- Grouped alerts by signature (GID:SID:REV) to highlight recurring detections
- Detected a burst of 3 alerts from the same source IP within a 5-minute window, demonstrating basic correlation logic

This workflow mirrors entry-level SOC alert triage and correlation processes.


